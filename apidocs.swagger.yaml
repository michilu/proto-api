swagger: "2.0"
info:
  title: An example of generating swagger via gRPC ecosystem.
  version: "1.0"
  contact:
    url: https://github.com/michilu/proto-api
    email: none@example.com
  license:
    name: Apache-2.0
    url: https://github.com/michilu/proto-api/blob/master/LICENSE
schemes:
- https
- wss
consumes:
- application/json
produces:
- application/json
paths:
  /healthCheck:
    get:
      operationId: HealthCheckService_HealthCheck
      responses:
        "200":
          description: A successful response.
          schema:
            $ref: '#/definitions/v1HealthCheckServiceHealthCheckResponse'
        default:
          description: An unexpected error response
          schema:
            $ref: '#/definitions/runtimeError'
      tags:
      - HealthCheckService
  /v1/example/{id}:
    post:
      operationId: ExampleService_Query
      responses:
        "200":
          description: A successful response.
          schema:
            $ref: '#/definitions/v1ExampleServiceQueryResponse'
        default:
          description: An unexpected error response
          schema:
            $ref: '#/definitions/runtimeError'
      parameters:
      - name: id
        in: path
        required: true
        type: string
      - name: body
        in: body
        required: true
        schema:
          $ref: '#/definitions/v1ExampleServiceQueryRequest'
      tags:
      - ExampleService
      security:
      - ApiKeyAuth: []
        OAuth2:
        - read
        - write
definitions:
  protobufAny:
    type: object
    properties:
      type_url:
        type: string
        description: |-
          A URL/resource name that uniquely identifies the type of the serialized
          protocol buffer message. This string must contain at least
          one "/" character. The last segment of the URL's path must represent
          the fully qualified name of the type (as in
          `path/google.protobuf.Duration`). The name should be in a canonical form
          (e.g., leading "." is not accepted).

          In practice, teams usually precompile into the binary all types that they
          expect it to use in the context of Any. However, for URLs which use the
          scheme `http`, `https`, or no scheme, one can optionally set up a type
          server that maps type URLs to message definitions as follows:

          * If no scheme is provided, `https` is assumed.
          * An HTTP GET on the URL must yield a [google.protobuf.Type][]
            value in binary format, or produce an error.
          * Applications are allowed to cache lookup results based on the
            URL, or have them precompiled into a binary to avoid any
            lookup. Therefore, binary compatibility needs to be preserved
            on changes to types. (Use versioned type names to manage
            breaking changes.)

          Note: this functionality is not currently available in the official
          protobuf release, and it is not used for type URLs beginning with
          type.googleapis.com.

          Schemes other than `http`, `https` (or the empty scheme) might be
          used with implementation specific semantics.
      value:
        type: string
        format: byte
        description: Must be a valid serialized protocol buffer of the above specified
          type.
    description: |-
      `Any` contains an arbitrary serialized protocol buffer message along with a
      URL that describes the type of the serialized message.

      Protobuf library provides support to pack/unpack Any values in the form
      of utility functions or additional generated methods of the Any type.

      Example 1: Pack and unpack a message in C++.

          Foo foo = ...;
          Any any;
          any.PackFrom(foo);
          ...
          if (any.UnpackTo(&foo)) {
            ...
          }

      Example 2: Pack and unpack a message in Java.

          Foo foo = ...;
          Any any = Any.pack(foo);
          ...
          if (any.is(Foo.class)) {
            foo = any.unpack(Foo.class);
          }

       Example 3: Pack and unpack a message in Python.

          foo = Foo(...)
          any = Any()
          any.Pack(foo)
          ...
          if any.Is(Foo.DESCRIPTOR):
            any.Unpack(foo)
            ...

       Example 4: Pack and unpack a message in Go

           foo := &pb.Foo{...}
           any, err := ptypes.MarshalAny(foo)
           ...
           foo := &pb.Foo{}
           if err := ptypes.UnmarshalAny(any, foo); err != nil {
             ...
           }

      The pack methods provided by protobuf library will by default use
      'type.googleapis.com/full.type.name' as the type URL and the unpack
      methods only use the fully qualified type name after the last '/'
      in the type URL, for example "foo.bar.com/x/y.z" will yield type
      name "y.z".


      JSON
      ====
      The JSON representation of an `Any` value uses the regular
      representation of the deserialized, embedded message, with an
      additional field `@type` which contains the type URL. Example:

          package google.profile;
          message Person {
            string first_name = 1;
            string last_name = 2;
          }

          {
            "@type": "type.googleapis.com/google.profile.Person",
            "firstName": <string>,
            "lastName": <string>
          }

      If the embedded message type is well-known and has a custom JSON
      representation, that representation will be embedded adding a field
      `value` which holds the custom JSON in addition to the `@type`
      field. Example (for message [google.protobuf.Duration][]):

          {
            "@type": "type.googleapis.com/google.protobuf.Duration",
            "value": "1.212s"
          }
  protov1Response:
    type: object
    properties:
      code:
        $ref: '#/definitions/rpcCode'
      message:
        type: string
  rpcCode:
    type: string
    enum:
    - OK
    - CANCELLED
    - UNKNOWN
    - INVALID_ARGUMENT
    - DEADLINE_EXCEEDED
    - NOT_FOUND
    - ALREADY_EXISTS
    - PERMISSION_DENIED
    - UNAUTHENTICATED
    - RESOURCE_EXHAUSTED
    - FAILED_PRECONDITION
    - ABORTED
    - OUT_OF_RANGE
    - UNIMPLEMENTED
    - INTERNAL
    - UNAVAILABLE
    - DATA_LOSS
    default: OK
    description: |-
      The canonical error codes for gRPC APIs.


      Sometimes multiple error codes may apply.  Services should return
      the most specific error code that applies.  For example, prefer
      `OUT_OF_RANGE` over `FAILED_PRECONDITION` if both codes apply.
      Similarly prefer `NOT_FOUND` or `ALREADY_EXISTS` over `FAILED_PRECONDITION`.

       - OK: Not an error; returned on success

      HTTP Mapping: 200 OK
       - CANCELLED: The operation was cancelled, typically by the caller.

      HTTP Mapping: 499 Client Closed Request
       - UNKNOWN: Unknown error.  For example, this error may be returned when
      a `Status` value received from another address space belongs to
      an error space that is not known in this address space.  Also
      errors raised by APIs that do not return enough error information
      may be converted to this error.

      HTTP Mapping: 500 Internal Server Error
       - INVALID_ARGUMENT: The client specified an invalid argument.  Note that this differs
      from `FAILED_PRECONDITION`.  `INVALID_ARGUMENT` indicates arguments
      that are problematic regardless of the state of the system
      (e.g., a malformed file name).

      HTTP Mapping: 400 Bad Request
       - DEADLINE_EXCEEDED: The deadline expired before the operation could complete. For operations
      that change the state of the system, this error may be returned
      even if the operation has completed successfully.  For example, a
      successful response from a server could have been delayed long
      enough for the deadline to expire.

      HTTP Mapping: 504 Gateway Timeout
       - NOT_FOUND: Some requested entity (e.g., file or directory) was not found.

      Note to server developers: if a request is denied for an entire class
      of users, such as gradual feature rollout or undocumented whitelist,
      `NOT_FOUND` may be used. If a request is denied for some users within
      a class of users, such as user-based access control, `PERMISSION_DENIED`
      must be used.

      HTTP Mapping: 404 Not Found
       - ALREADY_EXISTS: The entity that a client attempted to create (e.g., file or directory)
      already exists.

      HTTP Mapping: 409 Conflict
       - PERMISSION_DENIED: The caller does not have permission to execute the specified
      operation. `PERMISSION_DENIED` must not be used for rejections
      caused by exhausting some resource (use `RESOURCE_EXHAUSTED`
      instead for those errors). `PERMISSION_DENIED` must not be
      used if the caller can not be identified (use `UNAUTHENTICATED`
      instead for those errors). This error code does not imply the
      request is valid or the requested entity exists or satisfies
      other pre-conditions.

      HTTP Mapping: 403 Forbidden
       - UNAUTHENTICATED: The request does not have valid authentication credentials for the
      operation.

      HTTP Mapping: 401 Unauthorized
       - RESOURCE_EXHAUSTED: Some resource has been exhausted, perhaps a per-user quota, or
      perhaps the entire file system is out of space.

      HTTP Mapping: 429 Too Many Requests
       - FAILED_PRECONDITION: The operation was rejected because the system is not in a state
      required for the operation's execution.  For example, the directory
      to be deleted is non-empty, an rmdir operation is applied to
      a non-directory, etc.

      Service implementors can use the following guidelines to decide
      between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`:
       (a) Use `UNAVAILABLE` if the client can retry just the failing call.
       (b) Use `ABORTED` if the client should retry at a higher level
           (e.g., when a client-specified test-and-set fails, indicating the
           client should restart a read-modify-write sequence).
       (c) Use `FAILED_PRECONDITION` if the client should not retry until
           the system state has been explicitly fixed.  E.g., if an "rmdir"
           fails because the directory is non-empty, `FAILED_PRECONDITION`
           should be returned since the client should not retry unless
           the files are deleted from the directory.

      HTTP Mapping: 400 Bad Request
       - ABORTED: The operation was aborted, typically due to a concurrency issue such as
      a sequencer check failure or transaction abort.

      See the guidelines above for deciding between `FAILED_PRECONDITION`,
      `ABORTED`, and `UNAVAILABLE`.

      HTTP Mapping: 409 Conflict
       - OUT_OF_RANGE: The operation was attempted past the valid range.  E.g., seeking or
      reading past end-of-file.

      Unlike `INVALID_ARGUMENT`, this error indicates a problem that may
      be fixed if the system state changes. For example, a 32-bit file
      system will generate `INVALID_ARGUMENT` if asked to read at an
      offset that is not in the range [0,2^32-1], but it will generate
      `OUT_OF_RANGE` if asked to read from an offset past the current
      file size.

      There is a fair bit of overlap between `FAILED_PRECONDITION` and
      `OUT_OF_RANGE`.  We recommend using `OUT_OF_RANGE` (the more specific
      error) when it applies so that callers who are iterating through
      a space can easily look for an `OUT_OF_RANGE` error to detect when
      they are done.

      HTTP Mapping: 400 Bad Request
       - UNIMPLEMENTED: The operation is not implemented or is not supported/enabled in this
      service.

      HTTP Mapping: 501 Not Implemented
       - INTERNAL: Internal errors.  This means that some invariants expected by the
      underlying system have been broken.  This error code is reserved
      for serious errors.

      HTTP Mapping: 500 Internal Server Error
       - UNAVAILABLE: The service is currently unavailable.  This is most likely a
      transient condition, which can be corrected by retrying with
      a backoff. Note that it is not always safe to retry
      non-idempotent operations.

      See the guidelines above for deciding between `FAILED_PRECONDITION`,
      `ABORTED`, and `UNAVAILABLE`.

      HTTP Mapping: 503 Service Unavailable
       - DATA_LOSS: Unrecoverable data loss or corruption.

      HTTP Mapping: 500 Internal Server Error
  runtimeError:
    type: object
    properties:
      error:
        type: string
      code:
        type: integer
        format: int32
      message:
        type: string
      details:
        type: array
        items:
          $ref: '#/definitions/protobufAny'
  v1ExampleServiceQueryRequest:
    type: object
    properties:
      id:
        type: string
        minLength: 1
        pattern: '[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}'
  v1ExampleServiceQueryResponse:
    type: object
    properties:
      value:
        $ref: '#/definitions/protov1Response'
  v1HealthCheckServiceHealthCheckResponse:
    type: object
    properties:
      value:
        $ref: '#/definitions/protov1Response'
securityDefinitions:
  ApiKeyAuth:
    type: apiKey
    name: X-API-Key
    in: header
  OAuth2:
    type: oauth2
    flow: accessCode
    authorizationUrl: https://example.com/oauth/authorize
    tokenUrl: https://example.com/oauth/token
    scopes:
      admin: Grants read and write access to administrative information
      read: Grants read access
      write: Grants write access
security:
- ApiKeyAuth: []
  OAuth2:
  - read
  - write
